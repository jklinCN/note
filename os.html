<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>操作系统整理</title><link href='https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 2; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px !important; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none 0s ease 0s; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; margin-top: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="mermaid"] svg, [lang="flow"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }
svg[id^="mermaidChart"] { line-height: 1em; }
mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); }
.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; }
mark .md-meta { color: rgb(0, 0, 0); opacity: 0.3 !important; }


:root {
    --side-bar-bg-color: #fafafa;
    --control-text-color: #777;
}

@include-when-export url(https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext);

html {
    font-size: 16px;
}

body {
    font-family: "Open Sans","Clear Sans","Helvetica Neue",Helvetica,Arial,sans-serif;
    color: rgb(51, 51, 51);
    line-height: 1.6;
}

#write {
    max-width: 860px;
  	margin: 0 auto;
  	padding: 30px;
    padding-bottom: 100px;
}
#write > ul:first-child,
#write > ol:first-child{
    margin-top: 30px;
}

a {
    color: #4183C4;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 1rem;
    font-weight: bold;
    line-height: 1.4;
    cursor: text;
}
h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}
h1 tt,
h1 code {
    font-size: inherit;
}
h2 tt,
h2 code {
    font-size: inherit;
}
h3 tt,
h3 code {
    font-size: inherit;
}
h4 tt,
h4 code {
    font-size: inherit;
}
h5 tt,
h5 code {
    font-size: inherit;
}
h6 tt,
h6 code {
    font-size: inherit;
}
h1 {
    padding-bottom: .3em;
    font-size: 2.25em;
    line-height: 1.2;
    border-bottom: 1px solid #eee;
}
h2 {
   padding-bottom: .3em;
    font-size: 1.75em;
    line-height: 1.225;
    border-bottom: 1px solid #eee;
}
h3 {
    font-size: 1.5em;
    line-height: 1.43;
}
h4 {
    font-size: 1.25em;
}
h5 {
    font-size: 1em;
}
h6 {
   font-size: 1em;
    color: #777;
}
p,
blockquote,
ul,
ol,
dl,
table{
    margin: 0.8em 0;
}
li>ol,
li>ul {
    margin: 0 0;
}
hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

li p.first {
    display: inline-block;
}
ul,
ol {
    padding-left: 30px;
}
ul:first-child,
ol:first-child {
    margin-top: 0;
}
ul:last-child,
ol:last-child {
    margin-bottom: 0;
}
blockquote {
    border-left: 4px solid #dfe2e5;
    padding: 0 15px;
    color: #777777;
}
blockquote blockquote {
    padding-right: 0;
}
table {
    padding: 0;
    word-break: initial;
}
table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}
table tr:nth-child(2n),
thead {
    background-color: #f8f8f8;
}
table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    margin: 0;
    padding: 6px 13px;
}
table tr td {
    border: 1px solid #dfe2e5;
    margin: 0;
    padding: 6px 13px;
}
table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}
table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

.CodeMirror-lines {
    padding-left: 4px;
}

.code-tooltip {
    box-shadow: 0 1px 1px 0 rgba(0,28,36,.3);
    border-top: 1px solid #eef2f2;
}

.md-fences,
code,
tt {
    border: 1px solid #e7eaed;
    background-color: #f8f8f8;
    border-radius: 3px;
    padding: 0;
    padding: 2px 4px 0px 4px;
    font-size: 0.9em;
}

code {
    background-color: #f3f4f4;
    padding: 0 2px 0 2px;
}

.md-fences {
    margin-bottom: 15px;
    margin-top: 15px;
    padding-top: 8px;
    padding-bottom: 6px;
}


.md-task-list-item > input {
  margin-left: -1.3em;
}

@media print {
    html {
        font-size: 13px;
    }
    table,
    pre {
        page-break-inside: avoid;
    }
    pre {
        word-wrap: break-word;
    }
}

.md-fences {
	background-color: #f8f8f8;
}
#write pre.md-meta-block {
	padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block>.code-tooltip {
	bottom: .375rem;
}

.md-mathjax-midline {
    background: #fafafa;
}

#write>h3.md-focus:before{
	left: -1.5625rem;
	top: .375rem;
}
#write>h4.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
#write>h5.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
#write>h6.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
.md-image>.md-meta {
    /*border: 1px solid #ddd;*/
    border-radius: 3px;
    padding: 2px 0px 0px 4px;
    font-size: 0.9em;
    color: inherit;
}

.md-tag {
    color: #a7a7a7;
    opacity: 1;
}

.md-toc { 
    margin-top:20px;
    padding-bottom:20px;
}

.sidebar-tabs {
    border-bottom: none;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

/** focus mode */
.on-focus-mode blockquote {
    border-left-color: rgba(85, 85, 85, 0.12);
}

header, .context-menu, .megamenu-content, footer{
    font-family: "Segoe UI", "Arial", sans-serif;
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state{
    visibility: visible;
}

.mac-seamless-mode #typora-sidebar {
    background-color: #fafafa;
    background-color: var(--side-bar-bg-color);
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

#md-notification .btn {
    border: 0;
}

.dropdown-menu .divider {
    border-color: #e5e5e5;
}

.ty-preferences .window-content {
    background-color: #fafafa;
}

.ty-preferences .nav-group-item.active {
    color: white;
    background: #999;
}


</style>
</head>
<body class='typora-export os-windows' >
<div  id='write'  class = 'is-node'><h2><a name="操作系统概率章节概要" class="md-header-anchor"></a><span>《操作系统概率》章节概要</span></h2><h4><a name="chapter-1-introduction" class="md-header-anchor"></a><span>Chapter 1 Introduction</span></h4><ol start='' ><li><p><span>An operating system is software that manages the computer hardware, as well as providing an environment for application programs to run.</span></p><p><span>操作系统是一种管理计算机硬件和提供应用程序运行环境的软件。</span></p></li><li><p><span>A number of device controllers connected through a common bus that provides access between components and shared memory.</span></p><p><span>系统总线（system bus）提供计算机组件访问共享内存的渠道。（除系统总线外还有很多总线）</span></p></li><li><p><span>Interrupts are a key way in which hardware interacts with the operating system. A hardware device triggers an interrupt by sending a signal to the CPU to alert the CPU that some event requires attention.</span></p><p><span>中断是硬件与操作系统交互的关键。一个硬件设备通过给CPU发送信号触发一个中断，来警示CPU一些事件需要关注。</span></p><p><span>具体过程：The CPU hardware has a wire called the interrupt-request line that the CPU senses after executing every instruction. When the CPU detects that a controller has asserted a signal on the interrupt-request line, it reads the interrupt number and jumps to the interrupt-handler routine by using that interrupt number as an index into the interrupt vector. It then starts execution at the address associated with that index. The interrupt handler saves any state it will be changing during its operation, determines the cause of the interrupt, performs the necessary processing, performs a state restore, and executes a return_from_interrupt instruction to return the CPU to the execution state prior to the interrupt.</span></p></li><li><p><span>For a computer to do its job of executing programs, the programs must be in main memory, which is the only large storage area that the processor can access directly.</span></p><p><span>程序只有在处理器可以直接访问的主内存中才能执行。</span></p></li><li><p><span>Volatile storage will be referred to simply as memory.</span></p><p><span>主内存通常是易失性存储设备，当电源关闭或者消失时，会丢失存储的内容。</span></p></li><li><p><span>Nonvolatile storage is an extension of main memory and is capable of holding large quantities of data permanently. Nonvolatile storage retains its contents when power is lost. It will be referred to as NVS. The vast majority of the time we spend on NVS will be on secondary storage. </span></p><p><span>非易失性存储是主存的扩展，能够永久地保存大量数据。当电源消失时，非易失性存储会保留其存储的内容，称作NVS。我们花在NVS的时间大部分是在辅助存储上，分为两种类型：1.机械的，像机械硬盘、光盘、磁带；2.电子的，像闪存、FRAM、NRAM、SSD。</span></p></li><li><p><span>Modern computer architectures are multiprocessor systems in which each CPU contains several computing cores.</span></p><p><span>当代计算机体系结构是多处理器系统，每个CPU都包含多个计算核心。</span></p></li><li><p><span>To best utilize the CPU, modern operating systems employ multiprogramming, which allows several jobs to be in memory at the same time, thus ensuring that the CPU always has a job to execute.</span></p><p><span>为了最大化利用CPU，现代操作系统会采用多程序设计，允许一些工作同时处于内存中，以此确保CPU总有工作去执行。</span></p></li><li><p><span>Multitasking is an extension of multiprogramming where in CPU scheduling algorithms rapidly switch between processes, providing users with a fast response time.</span></p><p><span>多任务处理是多程序设计的一种扩展，其中的调度算法在进程之间快速切换，为用户提供更快的响应时间。</span></p></li><li><p><span>To prevent user programs from interfering with the proper operation of the system, the system hardware has two modes: user mode and kernel mode.</span></p><p><span>为了防止用户程序干扰系统的正常运行，系统硬件有两种模式:用户模式和内核模式。</span></p></li><li><p><span>A process is the fundamental unit of work in an operating system. Process management includes creating and deleting processes and providing mechanisms for processes to communicate and synchronize with each other.</span></p><p><span>进程是操作系统中的基本工作单元。进程管理包括创建和删除进程，以及为进程之间的通信和同步提供机制。</span></p></li><li><p><span>*An operating system manages memory by keeping track of what parts of memory are being used and by whom. It is also responsible for dynamically allocating and freeing memory space.</span></p><p><span>操作系统通过记录内存的哪些部分被谁使用来管理内存。它还负责动态分配和释放内存空间。</span></p></li><li><p><span>Virtualization involves abstracting a computer’s hardware into several different execution environments.</span></p><p><span>虚拟化涉及到把计算机硬件抽象到几个不同的执行环境中。</span></p></li></ol><h4><a name="chapter-2-operating-system-structures" class="md-header-anchor"></a><span>Chapter 2 Operating-System Structures</span></h4><ol start='' ><li><p><span>An operating system provides an environment for the execution of programs by providing services to users and programs.</span></p><p><span>一个操作系统通过给用户和程序提供服务来为程序执行提供一个环境。</span></p></li><li><p><span>The three primary approaches for interacting with an operating system are (1) command interpreters, (2) graphical user interfaces, and (3) touch-screen interfaces.</span></p><p><span>与操作系统进行交互的方法主要有三种：命令解释器、图形用户界面、触控屏界面。</span></p></li><li><p><span>System calls provide an interface to the services made available by an operating system. Programmers use a system call’s application programming interface (API) for accessing system-call services.</span></p><p><span>系统调用为操作系统提供的服务提供接口。程序员使用系统调用的应用程序编程接口(API)来访问系统调用服务。</span></p></li><li><p><span>A linker combines several relocatable object modules into a single binary executable file. A loader loads the executable file into memory, where it be comes eligible to run on an available CPU.</span></p><p><span>链接器将几个可重定位的对象模块组合到单个二进制可执行文件中。加载器将可执行文件加载到内存中，在那里它可以在可用的cpu上运行。</span></p></li><li><p><span>A monolithic operating system has no structure; all functionality is provided in a single, static binary file that runs in a single address space. Although such systems are difficult to modify, their primary benefit is efficiency.</span></p><p><span>单片操作系统没有结构，所有的功能都在一个运行在单个地址空间的静态二进制文件中提供。虽然这类系统很难修改，但它们的主要好处是效率。</span></p></li><li><p><span>The microkernel approach for designing operating systems uses a minimal kernel; most services run as user-level applications. Communication takes place via message passing.</span></p><p><span>用于设计操作系统的微内核方法使用一个最小的内核，大多数服务作为用户级应用程序运行。通信通过消息传递进行。</span></p></li><li><p><span>A modular approach for designing operating systems provides operating-system services through modules that can be loaded and removed during run time. Many contemporary operating systems are constructed as hybrid systems using a combination of a monolithic kernel and modules.</span></p><p><span>用于设计操作系统的模块化方法通过可在运行时加载和删除的模块来提供操作系统服务。 许多现代操作系统是使用整体内核和模块的组合构建为混合系统的。</span></p></li><li><p><span>A boot loader loads an operating system into memory, performs initialization, and begins system execution.</span></p><p><span>引导加载程序将操作系统加载到内存中，执行初始化，然后开始系统执行。</span></p></li></ol><h4><a name="chapter-3--processes" class="md-header-anchor"></a><span>Chapter 3  Processes</span></h4><ol start='' ><li><p><span>A process is a program in execution, and the status of the current activity of a process is represented by the program counter, as well as other registers.</span></p><p><span>进程是一个正在执行的程序，进程当前活动的状态由程序计数器和其他寄存器表示。</span></p></li><li><p><span>We emphasize that a program by itself is not a process. A program is a passive entity, such as a file containing a list of instructions stored on disk(often called an executable fil).In contrast,a process is an active entity,with a program counter specifying the next instruction to execute and a set of associated resources. A program becomes a process when an executable file is loaded into memory. </span></p><p><span>程序本身不是过程。 程序是静态实体，例如包含磁盘上存储的指令列表的文件（通常称为可执行文件）。相反，进程是动态实体，程序计数器指定要执行的下一条指令和一组相关资源。 当将可执行文件加载到内存中时，程序成为一个进程。 </span></p></li><li><p><span>The layout of a process in memory is represented by four different sections:(1) text, (2) data, (3) heap, and (4) stack.</span></p><p><span>进程在内存中的布局由四个不同的部分表示:(1)文本，(2)数据，(3)堆，(4)栈。</span></p></li><li><p><span>As a process executes, it changes state. There are four general states of a process: (1) ready, (2) running, (3) waiting, and (4) terminated.</span></p><p><span>当进程执行时，它会改变状态。进程一般有四种状态:(1)就绪，(2)运行，(3)等待，(4)终止。</span></p></li><li><p><span>A process control block (PCB) is the kernel data structure that represents a process in an operating system.</span></p><p><span>进程控制块(PCB)是操作系统中表示进程的核心数据结构。</span></p></li><li><p><span>The role of the process scheduler is to select an available process to run on a CPU.</span></p><p><span>进程调度程序的作用是选择一个可用的进程以在CPU上运行。</span></p></li><li><p><span>The fork() and CreateProcess() system calls are used to create pro-cesses on UNIX and Windows systems, respectively.</span></p><p><span>fork()和CreateProcess()系统调用分别用于在UNIX和Windows系统上创建process。</span></p></li><li><p><span>Cooperating processes require an interprocess communication(IPC)mechanism that will allow them to exchange data— that is, send data to and receive data from each other. There are two fundamental models of interprocess communication: shared memory and message passing.</span></p><p><span>进程协作需要一个进程间通信(IPC)机制，该机制允许进程间交换数据，即相互发送数据和接收数据。基本的进程间通信模型有两种：共享内存和消息传递。</span></p></li><li><p><span>A pipe provides a conduit for two processes to communicate. There are two forms of pipes, ordinary and named. Ordinary pipes are designed for communication between processes that have a parent–child relationship. Named pipes are more general and allow several processes to communicate.</span></p><p><span>管道(pipe)为两个进程提供了通信的渠道。管道有两种形式，普通管道和命名管道。普通管道是为具有父-子关系的进程之间的通信而设计的。命名管道更通用，允许多个进程相互通信。</span></p></li><li><p><span>UNIX systems provide ordinary pipes through the pipe() system call. Ordinary pipes have a read end and a write end. A parent process can, for example, send data to the pipe using its write end, and the child process can read it from its read end. Named pipes in UNIX are termed FIFOs.</span></p></li></ol><p><span>   UNIX systems通过the pipe()系统调用提供普通管道。普通管道有一个读取端和一个写入端。例如，父进程可以使用它的写入端向管道发送数据，子进程可以从它的读取端读取数据。UNIX中的命名管道称为FIFO。</span></p><ol start='11' ><li><p><span>Windows systems also provide two forms of pipes—anonymous and named pipes. Anonymous pipes are similar to UNIX ordinary pipes. They are unidirectional and employ parent–child relationships between the communicating processes. Named pipes offer a richer form of interprocess communication than the UNIX counterpart,FIFOs.</span></p><p><span>Windows系统也提供了两种形式的管道：匿名管道和命名管道。 匿名管道类似于UNIX的普通管道。 它们是单向的，并且在通信过程之间采用父子关系。 命名管道提供了比UNIX相对应的FIFO更丰富的进程间通信形式。</span></p></li><li><p><span>Two common forms of client–server communication are sockets and remote procedure calls (RPCs). Sockets allow two processes on different machines to communicate over a network. RPCs abstract the concept of function (procedure) calls in such a way that a function can be invoked on another process that may reside on a separate computer.</span></p><p><span>客户端与服务器通信的两种常见形式是套接字和远程过程调用（RPC）。 套接字允许不同机器上的两个进程通过网络进行通信。RPC抽象化函数（过程）调用的概念，这样可以在驻留在单独计算机上的另一个进程上调用一个函数。</span></p></li><li><p><span>The Android operating system uses RPCs as a form of interprocess communication using its binder framework.</span></p><p><span>Android操作系统使用其绑定程序框架将RPC用作进程间通信的一种形式。</span></p></li></ol><h4><a name="chapter-4-threads--concurrency" class="md-header-anchor"></a><span>Chapter 4 Threads &amp; Concurrency</span></h4><ol start='' ><li><p><span>A thread represents a basic unit of CPU utilization, and threads belonging to the same process share many of the process resources, including code and data.</span></p><p><span>线程是CPU利用中的一个基本单位，而属于同一进程的线程共享许多进程资源，包括代码和数据。</span></p></li><li><p><span>There are four primary benefits to multithreaded applications: (1) responsiveness, (2) resource sharing, (3) economy, and (4) scalability.</span></p><p><span>多线程应用程序有四个主要好处:(1)响应性，(2)资源共享，(3)经济性，(4)可伸缩性。</span></p></li><li><p><span>Concurrency exists when multiple threads are making progress, whereas parallelism exists when multiple threads are making progress simultaneously. On a system with a single CPU, only concurrency is possible;parallelism requires a multicore system that provides multiple CPUs.</span></p><p><span>当多个线程正在运行时，存在并发性；当多个线程同时进行时，存在并行性。在只有一个cpu的系统上，只有并发性是有可能的，并行性需要一个提供多个cpu的多核系统。</span></p><p><span>补充：Different concurrent designs enable different ways to parallelize.</span></p><p><span>“并发”指的是程序的结构，“并行”指的是程序运行时的状态。并发设计让并发执行成为可能，而并行是并发执行的一种模式。</span></p></li><li><p><span>Data parallelism distributes subsets of the same data across different computing cores and performs the same operation on each core. Task parallelism distributes not data but tasks across multiple cores. Each task is running a unique operation.</span></p><p><span>数据并行性将相同数据的子集分布在不同的计算核心上，并在每个核心上执行相同的操作。 任务并行化不在多个核心上分配数据，而是分配任务。 每个任务运行一个独特的操作。</span></p></li><li><p><span>User applications create user-level threads, which must ultimately be mapped to kernel threads to execute on a CPU. The many-to-one model maps many user-level threads to one kernel thread. Other approaches include the one-to-one and many-to-many models.</span></p><p><span>用户应用程序创建用户级线程，这些线程最终必须映射到内核线程才能在CPU上执行。 多对一模型将许多用户级线程映射到一个内核线程。 其他方法包括一对一和多对多模型。</span></p></li><li><p><span>A thread library provides an API for creating and managing threads. Three common thread libraries include Windows, Pthreads, and Java threading. Windows is for the Windows system only, while Pthreads is available for POSIX-compatible systems such as UNIX,Linux,and macOS. Java threads will run on any system that supports a Java virtual machine.</span></p><p><span>线程库提供用于创建和管理线程的API。 三种常见的线程库包括Windows，Pthreads和Java 线程。Windows仅用于Windows系统，而Pthreads可用于POSIX兼容系统，例如UNIX，Linux和macOS。Java线程将在支持Java虚拟机的任何系统上运行。</span></p></li><li><p><span>One way to address these difficulties and better support the design of concurrent and parallel applications is to transfer the creation and management of threading from application developers to compilers and run-time libraries. This strategy, termed implicit threading, is an increasingly popular trend. </span></p><p><span>解决这些困难并更好地支持并发和并行应用程序设计的一种方法是将线程的创建和管理从应用程序开发人员转移到编译器和运行时的库。这种称为隐式线程的策略是一种日益流行的趋势。</span></p></li><li><p><span>Implicit threading involves identifying tasks—not threads—and allowing languages or API frameworks to create and manage threads. There are several approaches to implicit threading, including thread pools, fork-join frameworks, and Grand Central Dispatch. Implicit threading is becoming an increasingly common technique for programmers to use in developing concurrent and parallel applications.</span></p><p><span>隐式线程涉及识别任务（而不是线程），并允许语言或API框架创建和管理线程。 隐式线程有几种方法，包括线程池，fork-join框架和Grand Central Dispatch。 隐式线程正成为程序员在开发并行和并行应用程序中使用的越来越普遍的技术。</span></p></li><li><p><span>Threads may be terminated using either asynchronous or deferred cancellation. Asynchronous cancellation stops a thread immediately, even if it is in the middle of performing an update. Deferred cancellation informs a thread that it should terminate but allows the thread to terminate in an orderly fashion. In most circumstances, deferred cancellation is preferred to asynchronous termination.</span></p><p><span>线程可以使用异步或延迟取消来终止。异步取消立即停止线程，即使它正处于执行更新的中间。延期取消通知一个线程它应该终止，但允许线程以一种有序的方式终止。在大多数情况下，延迟取消优先于异步终止。</span></p></li></ol><h4><a name="chapter-5-cpu-scheduling" class="md-header-anchor"></a><span>Chapter 5 CPU Scheduling</span></h4><ol start='' ><li><p><span>CPU scheduling is the task of selecting a waiting process from the ready queue and allocating the CPU to it. The CPU is allocated to the selected process by the dispatcher.</span></p><p><span>CPU调度是从就绪队列中选择一个等待进程并将CPU分配给它的任务。 CPU由调度程序分配给选定的进程。</span></p></li><li><p><span>Scheduling algorithms may be either preemptive (where the CPU can be taken away from a process) or nonpreemptive (where a process must voluntarily relinquish control of the CPU). Almost all modern operating systems are preemptive.</span></p><p><span>调度算法可以是抢占式（CPU可能会脱离进程），或者是非抢占式（进程必须自愿放弃对CPU的控制）。几乎所有现代操作系统都是抢占式的。</span></p></li><li><p><span>Scheduling algorithms can be evaluated according to the following five criteria: (1)CPU utilization, (2) throughput, (3) turnaround time, (4) waiting time, and (5) response time.</span></p><p><span>调度算法可以根据以下5个标准来评估:(1)CPU利用率，(2)吞吐量，(3)周转时间，(4)等待时间，(5)响应时间。</span></p></li><li><p><span>First-come, first-served (FCFS) scheduling is the simplest scheduling algorithm, but it can cause short processes to wait for very long processes.</span></p><p><span>先来先服务（FCFS）调度是最简单的调度算法，但是它可能导致较短的进程等待非常长的进程。</span></p></li><li><p><span>Shortest-job-first (SJF) scheduling is provably optimal, providing the shortest average waiting time. Implementing SJF scheduling is difficult, however, because predicting the length of the next CPU burst is difficult.</span></p><p><span>最短作业优先(SJF)调度是一种可以证明是最优的调度算法，它提供了最短的平均等待时间。但是，实现SJF调度很困难，因为很难预测下一个CPU突发的长度。</span></p></li><li><p><span>Round-robin (RR) scheduling allocates the CPU to each process for a time quantum. If the process does not relinquish the CPU before its time quantum expires, the process is preempted, and another process is scheduled to run for a time quantum.</span></p><p><span>轮询（RR）调度将CPU分配给每个进程并给一个时间量。 如果该进程在其时间量到期之前没有放弃CPU，则抢占该进程，并安排另一个进程运行一个时间段。</span></p></li><li><p><span>Priority scheduling assigns each process a priority, and the CPU is allocated to the process with the highest priority. Processes with the same priority can be scheduled in FCFS order or using RR scheduling.</span></p><p><span>优先级调度为每个进程分配一个优先级，并将CPU分配给具有最高优先级的进程。 具有相同优先级的进程可以按FCFS顺序或者RR调度进行调度。</span></p></li><li><p><span>Multilevel queue scheduling partitions processes into several separate queues arranged by priority, and the scheduler executes the processes in the highest-priority queue. Different scheduling algorithms may be used in each queue.</span></p><p><span>多级队列调度将进程划分为按优先级排列的几个单独的队列，调度程序在最高优先级的队列中执行进程。 在每个队列中可以使用不同的调度算法。</span></p></li><li><p><span>Multilevel feedback queues are similar to multilevel queues, except that a process may migrate between different queues.</span></p><p><span>多级反馈队列与多级队列相似，不同之处在于进程可以在不同的队列之间迁移。</span></p></li><li><p><span>Multicore processors place one or more CPUs on the same physical chip,and each CPU may have more than one hardware thread. From the perspective of the operating system, each hardware thread appears to be a logical CPU.</span></p><p><span>多核处理器将一个或多个CPU放在同一物理芯片上，每个CPU可能具有多个硬件线程。 从操作系统的角度来看，每个硬件线程都好像是逻辑CPU。</span></p></li><li><p><span>Load balancing on multicore systems equalizes loads between CPU cores,although migrating threads between cores to balance loads may invalidate cache contents and therefore may increase memory access times.</span></p><p><span>多核系统上的负载均衡可以均衡CPU内核之间的负载，尽管在内核之间迁移线程以平衡负载可能会使缓存内容无效，从而可能增加内存访问时间。</span></p></li><li><p><span>Soft real-time scheduling gives priority to real-time tasks over non-real-time tasks. Hard real-time scheduling provides timing guarantees for real-time tasks.</span></p><p><span>软实时调度将实时任务优先于非实时任务。 硬实时调度可为实时任务提供时间保证。</span></p></li><li><p><span>Rate-monotonic real-time scheduling schedules periodic tasks using astatic priority policy with preemption.</span></p><p><span>速率单调实时调度使用具有抢占权的静态优先级策略调度周期性任务。</span></p></li><li><p><span>Earliest-deadline-first (EDF) scheduling assigns priorities according to deadline. The earlier the deadline, the higher the priority; the later the deadline, the lower the priority.</span></p><p><span>最早截止时间优先（EDF）调度根据截止时间分配优先级。 截止日期越早，优先级越高； 截止日期越晚，优先级越低。</span></p></li><li><p><span>Proportional share scheduling allocates T shares among all applications. If an application is allocated N shares of time, it is ensured of having N/T of the total processor time.</span></p><p><span>比例份额调度在所有应用程序之间分配T个份额。 如果应用程序被分配到N个时间份额，则可以确保它拥有总处理器时间的N ∕ T。</span></p></li><li><p><span>Linux uses the completely fair scheduler (CFS), which assigns a proportion of CPU processing time to each task. The proportion is based on the virtual runtime (vruntime) value associated with each task.</span></p><p><span>Linux使用完全公平的调度程序（CFS），它为每个任务分配一定比例的CPU处理时间。 该比例基于与每个任务关联的虚拟运行时间（vruntime）的值。</span></p></li><li><p><span>Windows scheduling uses a preemptive, 32-level priority scheme to deter-mine the order of thread scheduling.</span></p><p><span>Windows调度使用抢占式的32级优先级方案来确定线程调度的顺序。</span></p></li><li><p><span>Solaris identifies six unique scheduling classes that are mapped to a global priority. CPU-intensive threads are generally assigned lower priorities(and longer time quantums), and I/O-bound threads are usually assigned higher priorities (with shorter time quantums.)</span></p><p><span>Solaris确定了六个映射到全局优先级的唯一调度类。通常将CPU密集型线程分配给较低的优先级（和更长的时间范围），并且将I / O绑定线程分配给更高的优先级（具有更短的时间范围）。</span></p></li></ol><h4><a name="chapter-6-synchronization-tools" class="md-header-anchor"></a><span>Chapter 6 Synchronization Tools</span></h4><ol start='' ><li><p><span>A race condition occurs when processes have concurrent access to shared data and the final result depends on the particular order in which con-current accesses occur. Race conditions can result in corrupted values of shared data.</span></p><p><span>当进程可以并发访问共享数据并且最终结果取决于并发访问发生的特定顺序时，就会发生竞争状态。 竞争状态可能导致共享数据的值损坏。</span></p></li><li><p><span>A critical section is a section of code where shared data may be manipulated and a possible race condition may occur. The critical-section problem is to design a protocol whereby processes can synchronize their activity to cooperatively share data.</span></p><p><span>临界区是代码的一部分，在其中共享数据可能被使用，并且可能发生竞争状态。临界区的问题是设计一个协议，使进程能够同步它们的活动，以协同地共享数据。</span></p></li><li><p><span>A solution to the critical-section problem must satisfy the following three requirements: (1) mutual exclusion, (2) progress, and (3) bounded waiting. Mutual exclusion ensures that only one process at a time is active in its critical section. Progress ensures that programs will cooperatively determine what process will next enter its critical section. Bounded waiting limit show much time a program will wait before it can enter its critical section.</span></p><p><span>临界区问题的解决方案必须满足以下三个要求：（1）相互排斥，（2）进展，（3）有界等待。相互排斥确保在临界区中一次仅激活一个进程 。 进展确保程序将协作确定下一步将进入临界区的进程。 有界的等待限制显示程序在进入临界区之前需要等待的时间。</span></p></li><li><p><span>Software solutions to the critical-section problem, such as Peterson’s solution, do not work well on modern computer architectures.</span></p><p><span>临界区问题的软件解决方案（例如Peterson的解决方案）在现代计算机体系结构上效果不好。</span></p></li><li><p><span>Hardware support for the critical-section problem includes memory barriers; hardware instructions, such as the compare-and-swap instruction; and atomic variables.</span></p><p><span>临界区问题的硬件支持包括内存限制、硬件指令（如比较和交换指令）和原子变量。</span></p></li><li><p><span>A mutex lock provides mutual exclusion by requiring that a process acquire a lock before entering a critical section and release the lock on exiting the critical section.</span></p><p><span>互斥锁通过要求进程在进入临界区之前获取一个锁并释放与该临界区对应的锁来提供互斥。</span></p></li><li><p><span>Semaphores, like mutex locks, can be used to provide mutual exclusion. However, whereas a mutex lock has a binary value that indicates if the lock is available or not, a semaphore has an integer value and can therefore be used to solve a variety of synchronization problems.</span></p><p><span>信号量，就像互斥锁一样，可以用来提供互斥。然而，互斥锁有一个二进制值来指示锁是否可用，而信号量有一个整数值，因此可以用来解决各种同步问题。</span></p></li><li><p><span>A monitor is an abstract data type that provides a high-level form of process synchronization. A monitor uses condition variables that allow processes to wait for certain conditions to become true and to signal one another when conditions have been set to true.</span></p><p><span>监视器是一种抽象的数据类型，提供了高级形式的进程同步。 监视器使用条件变量，这些条件变量允许进程等待某些条件变为真，并在条件设置为真时互相发出信号。</span></p></li><li><p><span>Solutions to the critical-section problem may suffer from liveness problems, including deadlock.</span></p><p><span>临界区问题的解决方案可能会遇到活性问题，包括死锁。</span></p></li><li><p><span>The various tools that can be used to solve the critical-section problem as well as to synchronize the activity of processes can be evaluated under varying levels of contention. Some tools work better under certain contention loads than others.</span></p><p><span>可以在各种竞争水平下评估可用于解决关键部分问题以及同步流程活动的各种工具。 有些工具在某些工作量负载下比其他工具更好。</span></p></li></ol><h4><a name="chapter-7-synchronization-examples" class="md-header-anchor"></a><span>Chapter 7 Synchronization Examples</span></h4><ol start='' ><li><p><span>Classic problems of process synchronization include the bounded-buffer,readers–writers, and dining-philosophers problems. Solutions to these problems can be developed using the tools presented in Chapter 6, including mutex locks, semaphores, monitors, and condition variables.</span></p><p><span>流程同步的经典问题包括有限缓冲区，读者-作家和用餐哲学家问题。 可以使用第6章中介绍的工具开发这些问题的解决方案，包括互斥锁，信号量，监视器和条件变量。</span></p></li><li><p><span>Windows uses dispatcher objects as well as events to implement process synchronization tools.</span></p><p><span>Windows使用调度程序对象和事件来实现进程同步工具。</span></p></li><li><p><span>Linux uses a variety of approaches to protect against race conditions,including atomic variables, spinlocks, and mutex locks.</span></p><p><span>Linux使用多种方法来防止竞争情况，包括原子变量，自旋锁和互斥锁。</span></p></li><li><p><span>The POSIX API provides mutex locks, semaphores, and condition variables. POSIX provides two forms of semaphores: named and unnamed. Several unrelated processes can easily access the same named semaphore by simply referring to its name. Unnamed semaphores cannot be shared as easily,and require placing the semaphore in a region of shared memory.</span></p><p><span>POSIX API提供互斥锁，信号量和条件变量。POSIX提供两种形式的信号量：已命名和未命名。 几个不相关的进程可以通过简单地引用其名称来轻松访问相同的已命名的信号量。 未命名的信号量不能轻易共享，需要将信号量放置在共享内存的区域中</span></p></li><li><p><span>Java has a rich library and API for synchronization. Available tools include monitors (which are provided at the language level) as well as reentrant locks, semaphores, and condition variables (which are supported by the API).</span></p><p><span>Java有一个丰富的库和用于同步的API。 可用的工具包括监视器（在语言级别提供）以及可重入锁，信号量和条件变量（API支持）</span></p></li><li><p><span>Alternative approaches to solving the critical-section problem include transactional memory, OpenMP, and functional languages. Functional languages are particularly intriguing, as they offer a different programming paradigm from procedural languages. Unlike procedural languages, functional languages do not maintain state and therefore are generally immune from race conditions and critical sections.</span></p><p><span>解决临界区问题的替代方法包括事务存储，OpenMP和功能语言。 功能语言特别吸引人，因为它们提供了与程序语言不同的编程范例。 与程序语言不同，功能语言不会保持状态，因此通常不受竞争状态和临界区的影响。</span></p></li></ol><h4><a name="chapter-8-deadlock" class="md-header-anchor"></a><span>Chapter 8 Deadlock</span></h4><ol start='' ><li><p><span>Deadlock occurs in a set of processes when every process in the set is waiting for an event that can only be caused by another process in the set.</span></p><p><span>当一组进程中的每个进程都在等待一个只能由该集中的另一个进程引起的事件时，就会发生死锁。</span></p><p><span>抽象解释：Perhaps the best illustration of a deadlock can be drawn from a law passed by the Kansas legislature early in the 20th century. It said, in part:“When two trains approach each other at a crossing, both shall come to a full stop and neither shall start up again until the other has gone.”</span></p><p><span>当两列火车在交叉口接近时，两列列车应完全停止，在另一列列车离开之前，任何一列列车都不得重新启动。</span></p></li><li><p><span>There are four necessary conditions for deadlock: (1) mutual exclusion, (2)hold and wait, (3) no preemption, and (4) circular wait. Deadlock is only possible when all four conditions are present.</span></p><p><span>死锁有四个必要条件：（1）互斥，（2）保持等待，（3）无抢占，（4）循环等待。只有当所有四个条件都存在时，才可能出现死锁。</span></p></li><li><p><span>Deadlocks can be modelled with resource-allocation graphs, where a cycle indicates deadlock.</span></p><p><span>死锁可以用资源分配图建模，其中循环表示死锁。</span></p></li><li><p><span>Deadlocks can be prevented by ensuring that one of the four necessary conditions for deadlock cannot occur. Of the four necessary conditions,eliminating the circular wait is the only practical approach.</span></p><p><span>可以确保死锁的四个必要条件之一不会发生来防止死锁。 在这四个必要条件中，消除循环等待是唯一可行的方法。</span></p></li><li><p><span>Deadlock can be avoided by using the banker’s algorithm, which does not grant resources if doing so would lead the system into an unsafe state where deadlock would be possible.</span></p><p><span>死锁可以通过使用银行家算法来避免，如果这样做会导致系统进入可能出现死锁的不安全状态，那么就不会授予资源。</span></p></li><li><p><span>A deadlock-detection algorithm can evaluate processes and resources on a running system to determine if a set of processes is in a deadlocked state.</span></p><p><span>死锁检测算法可以评估正在运行的系统上的进程和资源，以确定一组进程是否处于死锁状态。</span></p></li><li><p><span>If deadlock does occur, a system can attempt to recover from the deadlock by either aborting one of the processes in the circular wait or preempting resources that have been assigned to a deadlocked process.</span></p><p><span>如果确实发生死锁，系统可以通过中止循环等待中的某个进程或抢占已分配给死锁进程的资源来尝试从死锁中恢复。</span></p></li></ol><h4><a name="chapter-9-main-memory" class="md-header-anchor"></a><span>Chapter 9 Main Memory</span></h4><ol start='' ><li><p><span>Memory is central to the operation of a modern computer system and consists of a large array of bytes, each with its own address.</span></p><p><span>内存是现代计算机系统操作的中心，由大量字节组成，每个字节都有自己的地址。</span></p></li><li><p><span>One way to allocate an address space to each process is through the use of base and limit registers. The base register holds the smallest legal physical memory address, and the limit specifies the size of the range.</span></p><p><span>给每个进程分配地址空间的一种方法是使用基本寄存器和限制寄存器。基本寄存器保存了最小的合法物理内存地址，限制寄存器指定了范围的大小。</span></p></li><li><p><span>Binding symbolic address references to actual physical addresses may occur during (1) compile, (2) load, or (3) execution time.</span></p><p><span>将抽象地址引用绑定到实际物理地址可能发生在(1)编译，(2)加载，(3)执行时。</span></p></li><li><p><span>An address generated by the CPU is known as a logical address, which the memory management unit (MMU)translates to a physical address in memory.</span></p><p><span>由CPU生成的地址称为逻辑地址，内存管理单元（MMU）将其转换为内存中的物理地址。</span></p></li><li><p><span>One approach to allocating memory is to allocate partitions of contiguous memory of varying sizes. These partitions may be allocated based on three possible strategies: (1) first fit, (2) best fit, and (3) worst fit.</span></p><p><span>分配内存的一种方法是分配大小不一的连续分区。这些分区可以根据三种策略进行分配:(1)首先满足、(2)最佳满足和(3)最差满足。</span></p></li><li><p><span>Modern operating systems use paging to manage memory. In this process,physical memory is divided into fixed-sized blocks called frames and logical memory into blocks of the same size called pages.</span></p><p><span>现代操作系统使用分页来管理内存。在这个过程中，物理内存被划分为固定大小的块，称为帧，逻辑内存被划分为相同大小的块，称为页面。</span></p></li><li><p><span>When paging is used, a logical address is divided into two parts: a page number and a page offset. The page number serves as an index into a per-process page table that contains the frame in physical memory that holds the page. The offset is the specific location in the frame being referenced.</span></p><p><span>使用分页时，逻辑地址分为两部分：页码和页偏移。 页码用作每个进程页表的索引，该表包含保存该页的物理内存中的帧。 偏移量是被引用帧中的特定位置。</span></p></li><li><p><span>A translation look-aside buffer (TLB) is a hardware cache of the page table. Each TLB entry contains a page number and its corresponding frame.</span></p><p><span>转译后备缓冲区(TLB)是页表的硬件缓存。每个TLB包含一个页码和相应的帧。</span></p></li><li><p><span>Using a TLB in address translation for paging systems involves obtaining the page number from the logical address and checking if the frame for the page is in the TLB. If it is, the frame is obtained from the TLB. If the frame is not present in the TLB, it must be retrieved from the page table.</span></p><p><span>在分页系统的地址转换中使用TLB涉及到从逻辑地址获取页码，并检查页面的帧是否在TLB中。如果是，则从TLB获得帧。如果帧不在TLB中，则必须从页表中检索它。</span></p></li><li><p><span>Hierarchical paging involves dividing a logical address into multiple parts,each referring to different levels of page tables. As addresses expand beyond 32 bits, the number of hierarchical levels may become large. Two strategies that address this problem are hashed page tables and inverted page tables.</span></p><p><span>分层分页涉及到将逻辑地址划分为多个部分，每个部分引用不同级别的页表。当地址扩展到32位以上时，分层级别的数目可能会变大。解决这个问题的两种策略是散列页表和反转页表。</span></p></li><li><p><span>Swapping allows the system to move pages belonging to a process to disk to increase the degree of multiprogramming.</span></p><p><span>交换允许系统将属于某个进程的页面移动到磁盘上，以提高多道程序设计的程度。</span></p></li><li><p><span>The Intel 32-bit architecture has two levels of page tables and supports either 4-KB or 4-MB page sizes. This architecture also supports page-address extension, which allows 32-bit processors to access a physical address space larger than 4GB. The x86-64 andARMv9 architectures are 64-bit architectures that use hierarchical paging.</span></p><p><span>英特尔32位体系结构具有两个级别的页表，并支持4 KB或4 MB页面大小。 该体系结构还支持页面地址扩展，该扩展允许32位处理器访问大于4GB的物理地址空间。 x86-64和ARMv9体系结构是使用分层分页的64位体系结构。</span></p></li></ol><h4><a name="chapter-10-virtual-memory" class="md-header-anchor"></a><span>Chapter 10 Virtual Memory</span></h4><ol start='' ><li><p><span>Virtual memory abstracts physical memory into an extremely large uniform array of storage.</span></p><p><span>虚拟内存将物理内存抽象为一个非常大的统一存储阵列。</span></p></li><li><p><span>The benefits of virtual memory include the following: (1) a program can be larger than physical memory, (2) a program does not need to be entirely in memory, (3) processes can share memory, and (4) processes can be created more efficiently</span></p><p><span>虚拟内存的好处包括：（1）程序可以大于物理内存，（2）程序不需要完全处于内存中，（3）进程可以共享内存，并且（4）可以更有效地创建进程 。</span></p></li><li><p><span>Demand paging is a technique whereby pages are loaded only when they are demanded during program execution. Pages that are never demanded are thus never loaded into memory.</span></p><p><span>请求分页是一种仅在程序执行过程中需要页面时才加载页面的技术。从不被需要的页面也就不会被加载到内存中。</span></p></li><li><p><span>A page fault occurs when a page that is currently not in memory is accessed. The page must be brought from the backing store into an available page frame in memory.</span></p><p><span>当访问当前不在内存中的页面时，将发生页面错误。 页面必须从备份存储区带到内存中可用的页帧中。</span></p></li><li><p><span>Copy-on-write allows a child process to share the same address space as its parent. If either the child or the parent process writes (modifies) a page,a copy of the page is made.</span></p><p><span>写入时复制允许子进程与其父进程共享相同的地址空间。 如果子进程或父进程写入（修改）页面，页面会创造一个副本。</span></p></li><li><p><span>When available memory runs low, a page-replacement algorithm selects an existing page in memory to replace with a new page. Page-replacement algorithms include FIFO,optimal,and LRU. Pure LRU algorithms are impractical to implement, and most systems instead use LRU-approximation algorithms.</span></p><p><span>当可用内存不足时，页面替换算法会选择内存中现有的页面来替换为新页面。页面替换算法包括FIFO，最优和LRU。纯LRU算法难以实现，大多数系统使用的是LRU近似算法。</span></p></li><li><p><span>Global page-replacement algorithms select a page from any process in the system for replacement, while local page-replacement algorithms select a page from the faulting process.</span></p><p><span>全局页面替换算法从系统中的任何进程中选择一个页面进行替换，而本地页面替换算法从故障过程中选择一个页面。</span></p></li><li><p><span>Thrashing occurs when a system spends more time paging than executing.</span></p><p><span>当系统分页时间多于执行时间时，就会发生抖动。</span></p></li><li><p><span>*A locality represents a set of pages that are actively used together. As a process executes, it moves from locality to locality. A working set is based on locality and is defined as the set of pages currently in use by a process.</span></p><p><span>局部性表示一组同时被激活的页面。当一个进程执行时，它从一个地方移动到另一个地方。工作集是基于局部性的，定义为进程当前使用的页面集。</span></p></li><li><p><span>Memory compression is a memory-management technique that compresses a number of pages into a single page. Compressed memory is an alternative to paging and is used on mobile systems that do not support paging</span></p><p><span>内存压缩是一种内存管理技术，它将多个页面压缩为单个页面。压缩内存是分页的另一种选择，用于不支持分页的移动系统。</span></p></li><li><p><span>Kernel memory is allocated differently than user-mode processes; it is allocated in contiguous chunks of varying sizes. Two common techniques for allocating kernel memory are (1) the buddy system and (2) slab allocation.</span></p><p><span>内核内存的分配与用户模式进程的分配不同； 它被分配在不同大小的连续块中。 分配内核内存的两种常用技术是（1）伙伴系统和（2）slab分配。</span></p></li><li><p><span>TLB reach refers to the amount of memory accessible from the TLB and is equal to the number of entries in the TLB multiplied by the page size. One technique for increasing TLB reach is to increase the size of pages.</span></p><p><span>TLB范围是指可从TLB访问的内存量，等于TLB中的条目数乘以页面大小。 增加TLB覆盖率的一种技术是增加页面大小。</span></p></li><li><p><span>Linux, Windows, and Solaris manage virtual memory similarly, using demand paging and copy-on-write, among other features. Each system also uses a variation of LRU approximation known as the clock algorithm.</span></p><p><span>Linux，Windows和Solaris使用请求分页和写入时复制等功能来类似地管理虚拟内存。 每种系统还使用一种LRU近似的变体，称为时钟算法。</span></p></li></ol><h4><a name="chapter-11-mass-storage-structure" class="md-header-anchor"></a><span>Chapter 11 Mass-Storage Structure</span></h4><ol><li><p><span>Hard disk drives and nonvolatile memory devices are the major secondary storage I/O units on most computers. Modern secondary storage is structured as large one-dimensional arrays of logical blocks.</span></p><p><span>硬盘驱动器和非易失性存储设备是大多数计算机的主要辅助存储设备。现代辅助存储的结构是逻辑块的大型一维数组。</span></p></li><li><p><span>Drives of either type may be attached to a computer system in one of three ways: (1) through the local I/O ports on the host computer, (2) directly connected to motherboards, or (3) through a communications network or storage network connection.</span></p><p><span>任何一种类型的驱动器都可以通过以下三种方式之一连接到计算机系统：（1）通过主机的本地I/O端口，（2）直接连接到主板，或（3）通过通信网络或存储网络连接。</span></p></li><li><p><span>Requests for secondary storage I/O are generated by the file system and by the virtual memory system. Each request specifies the address on the device to be referenced in the form of a logical block number.</span></p><p><span>文件系统和虚拟内存系统生成对辅助存储I / O的请求。 每个请求都以逻辑块号的形式指定要引用的设备上的地址。</span></p></li><li><p><span>Disk-scheduling algorithms can improve the effective bandwidth of HDDs,the average response time, and the variance in response time. Algorithms such as SCAN and C-SCAN are designed to make such improvements through strategies for disk-queue ordering. Performance of disk-scheduling algorithms can vary greatly on hard disks. In contrast, because solid-state disks have no moving parts, performance varies little among scheduling algorithms, and quite often a simple FCFS strategy is used.</span></p><p><span>磁盘调度算法可以改善HDD的有效带宽，平均响应时间以及响应时间的差异。 诸如SCAN和C-SCAN的算法旨在通过磁盘队列排序策略进行这类改进。 磁盘调度算法的性能在硬盘上可能有很大差异。 相比之下，由于固态磁盘没有活动部件，因此调度算法之间的性能差异很小，并且经常使用简单的FCFS策略。</span></p></li><li><p><span>Data storage and transmission are complex and frequently result in errors. Error detection attempts to spot such problems to alert the system for corrective action and to avoid error propagation. Error correction can detect and repair problems, depending on the amount of correction data available and the amount of data that was corrupted.</span></p><p><span>数据的存储和传输非常复杂，经常会导致错误。错误检测会尝试发现此类问题，以警告系统采取纠正措施并避免错误传播。 纠错可以检测和修复问题，具体取决于可用的纠正数据量和损坏的数据量。</span></p></li><li><p><span>Storage devices are partitioned into one or more chunks of space. Each partition can hold a volume or be part of a multidevice volume. Filesystems are created in volumes.</span></p><p><span>存储设备被划分为一个或多个空间块。每个分区可以保存一个卷，也可以是多设备卷的一部分。文件系统在卷中创建。</span></p></li><li><p><span>The operating system manages the storage device’s blocks. New devices typically come pre-formatted. The device is partitioned, file systems are created, and boot blocks are allocated to store the system’s bootstrap program if the device will contain an operating system. Finally, when a block or page is corrupted, the system must have a way to lock out that block or to replace it logically with a spare.</span></p><p><span>操作系统管理存储设备的块。 新设备通常已预先格式化。 如果设备将包含操作系统，则对该设备进行分区，创建文件系统并分配启动块以存储系统的引导程序。 最后，当一个块或页被损坏时，系统必须有一种方法来锁定该块，或者逻辑上用一个备用块替换它。</span></p></li><li><p><span>An efficient swap space is a key to good performance in some systems. Some systems dedicate a raw partition to swap space, and others use a file with in the file system instead. Still other systems allow the user or system administrator to make the decision by providing both options.</span></p><p><span>在某些系统中，有效的交换空间是获得良好性能的关键。有些系统专门使用原始分区来交换空间，而其他系统则使用文件系统中的文件。还有一些系统允许用户或系统管理员通过提供这两种选项来做出决定。</span></p></li><li><p><span>Because of the amount of storage required on large systems, and because storage devices fail in various ways, secondary storage devices are frequently made redundant via RAID algorithms. These algorithms allow more than one drive to be used for a given operation and allow continued operation and even automatic recovery in the face of a drive failure. RAID algorithms are organized into different levels; each level provides some combination of reliability and high transfer rates.</span></p><p><span>由于大型系统上需要大量存储，并且由于存储设备会以各种方式发生故障，因此经常会通过RAID算法使辅助存储设备冗余。 这些算法允许多个驱动器用于给定的操作，并在遇到驱动器故障时允许继续操作，甚至自动恢复。RAID算法分为不同的级别；每个级别提供了可靠性和高传输速率的某种组合。</span></p></li><li><p><span>Object storage is used for big data problems such as indexing the Internet and cloud photo storage. Objects are self-defining collections of data,addressed by object ID rather than file name. Typically it uses replication for data protection, computes based on the data on systems where a copy of the data exists, and is horizontally scalable for vast capacity and easy expansion.</span></p><p><span>对象存储用于解决互联网索引、云存储等大数据问题。对象是自定义的数据集合，通过对象ID而不是文件名进行定位。通常，它使用复制来进行数据保护，根据存在数据副本的系统上的数据进行计算，并且可以水平伸缩，以实现巨大的容量和简单的扩展。</span></p></li></ol><h4><a name="chapter-12-io-systems" class="md-header-anchor"></a><span>Chapter 12 I/O Systems</span></h4><ol><li></li></ol></div>
</body>
</html>